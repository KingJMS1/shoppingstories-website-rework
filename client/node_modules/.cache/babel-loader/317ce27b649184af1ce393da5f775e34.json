{"ast":null,"code":"const Table = require('cli-table3');\n\nconst chalk = require('chalk');\n\nconst {\n  v4: isCidrV4,\n  v6: isCidrV6\n} = require('is-cidr');\n\nconst log = require('../utils/log-shim.js');\n\nconst profile = require('npm-profile');\n\nconst otplease = require('../utils/otplease.js');\n\nconst pulseTillDone = require('../utils/pulse-till-done.js');\n\nconst readUserInfo = require('../utils/read-user-info.js');\n\nconst BaseCommand = require('../base-command.js');\n\nclass Token extends BaseCommand {\n  static description = 'Manage your authentication tokens';\n  static name = 'token';\n  static usage = ['list', 'revoke <id|token>', 'create [--read-only] [--cidr=list]'];\n  static params = ['read-only', 'cidr', 'registry', 'otp'];\n  static ignoreImplicitWorkspace = true;\n\n  async completion(opts) {\n    const argv = opts.conf.argv.remain;\n    const subcommands = ['list', 'revoke', 'create'];\n\n    if (argv.length === 2) {\n      return subcommands;\n    }\n\n    if (subcommands.includes(argv[2])) {\n      return [];\n    }\n\n    throw new Error(argv[2] + ' not recognized');\n  }\n\n  async exec(args, cb) {\n    log.gauge.show('token');\n\n    if (args.length === 0) {\n      return this.list();\n    }\n\n    switch (args[0]) {\n      case 'list':\n      case 'ls':\n        return this.list();\n\n      case 'delete':\n      case 'revoke':\n      case 'remove':\n      case 'rm':\n        return this.rm(args.slice(1));\n\n      case 'create':\n        return this.create(args.slice(1));\n\n      default:\n        throw this.usageError(`${args[0]} is not a recognized subcommand.`);\n    }\n  }\n\n  async list() {\n    const conf = this.config();\n    log.info('token', 'getting list');\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf));\n\n    if (conf.json) {\n      this.npm.output(JSON.stringify(tokens, null, 2));\n      return;\n    } else if (conf.parseable) {\n      this.npm.output(['key', 'token', 'created', 'readonly', 'CIDR whitelist'].join('\\t'));\n      tokens.forEach(token => {\n        this.npm.output([token.key, token.token, token.created, token.readonly ? 'true' : 'false', token.cidr_whitelist ? token.cidr_whitelist.join(',') : ''].join('\\t'));\n      });\n      return;\n    }\n\n    this.generateTokenIds(tokens, 6);\n    const idWidth = tokens.reduce((acc, token) => Math.max(acc, token.id.length), 0);\n    const table = new Table({\n      head: ['id', 'token', 'created', 'readonly', 'CIDR whitelist'],\n      colWidths: [Math.max(idWidth, 2) + 2, 9, 12, 10]\n    });\n    tokens.forEach(token => {\n      table.push([token.id, token.token + '…', String(token.created).slice(0, 10), token.readonly ? 'yes' : 'no', token.cidr_whitelist ? token.cidr_whitelist.join(', ') : '']);\n    });\n    this.npm.output(table.toString());\n  }\n\n  async rm(args) {\n    if (args.length === 0) {\n      throw this.usageError('`<tokenKey>` argument is required.');\n    }\n\n    const conf = this.config();\n    const toRemove = [];\n    const progress = log.newItem('removing tokens', toRemove.length);\n    progress.info('token', 'getting existing list');\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf));\n    args.forEach(id => {\n      const matches = tokens.filter(token => token.key.indexOf(id) === 0);\n\n      if (matches.length === 1) {\n        toRemove.push(matches[0].key);\n      } else if (matches.length > 1) {\n        throw new Error(\n        /* eslint-disable-next-line max-len */\n        `Token ID \"${id}\" was ambiguous, a new token may have been created since you last ran \\`npm token list\\`.`);\n      } else {\n        const tokenMatches = tokens.some(t => id.indexOf(t.token) === 0);\n\n        if (!tokenMatches) {\n          throw new Error(`Unknown token id or value \"${id}\".`);\n        }\n\n        toRemove.push(id);\n      }\n    });\n    await Promise.all(toRemove.map(key => {\n      return otplease(this.npm, conf, conf => {\n        return profile.removeToken(key, conf);\n      });\n    }));\n\n    if (conf.json) {\n      this.npm.output(JSON.stringify(toRemove));\n    } else if (conf.parseable) {\n      this.npm.output(toRemove.join('\\t'));\n    } else {\n      this.npm.output('Removed ' + toRemove.length + ' token' + (toRemove.length !== 1 ? 's' : ''));\n    }\n  }\n\n  async create(args) {\n    const conf = this.config();\n    const cidr = conf.cidr;\n    const readonly = conf.readOnly;\n    return readUserInfo.password().then(password => {\n      const validCIDR = this.validateCIDRList(cidr);\n      log.info('token', 'creating');\n      return pulseTillDone.withPromise(otplease(this.npm, conf, conf => {\n        return profile.createToken(password, readonly, validCIDR, conf);\n      }));\n    }).then(result => {\n      delete result.key;\n      delete result.updated;\n\n      if (conf.json) {\n        this.npm.output(JSON.stringify(result));\n      } else if (conf.parseable) {\n        Object.keys(result).forEach(k => this.npm.output(k + '\\t' + result[k]));\n      } else {\n        const table = new Table();\n\n        for (const k of Object.keys(result)) {\n          table.push({\n            [chalk.bold(k)]: String(result[k])\n          });\n        }\n\n        this.npm.output(table.toString());\n      }\n    });\n  }\n\n  config() {\n    const conf = { ...this.npm.flatOptions\n    };\n    const creds = this.npm.config.getCredentialsByURI(conf.registry);\n\n    if (creds.token) {\n      conf.auth = {\n        token: creds.token\n      };\n    } else if (creds.username) {\n      conf.auth = {\n        basic: {\n          username: creds.username,\n          password: creds.password\n        }\n      };\n    } else if (creds.auth) {\n      const auth = Buffer.from(creds.auth, 'base64').toString().split(':', 2);\n      conf.auth = {\n        basic: {\n          username: auth[0],\n          password: auth[1]\n        }\n      };\n    } else {\n      conf.auth = {};\n    }\n\n    if (conf.otp) {\n      conf.auth.otp = conf.otp;\n    }\n\n    return conf;\n  }\n\n  invalidCIDRError(msg) {\n    return Object.assign(new Error(msg), {\n      code: 'EINVALIDCIDR'\n    });\n  }\n\n  generateTokenIds(tokens, minLength) {\n    const byId = {};\n\n    for (const token of tokens) {\n      token.id = token.key;\n\n      for (let ii = minLength; ii < token.key.length; ++ii) {\n        const match = tokens.some(ot => ot !== token && ot.key.slice(0, ii) === token.key.slice(0, ii));\n\n        if (!match) {\n          token.id = token.key.slice(0, ii);\n          break;\n        }\n      }\n\n      byId[token.id] = token;\n    }\n\n    return byId;\n  }\n\n  validateCIDRList(cidrs) {\n    const maybeList = cidrs ? Array.isArray(cidrs) ? cidrs : [cidrs] : [];\n    const list = maybeList.length === 1 ? maybeList[0].split(/,\\s*/) : maybeList;\n\n    for (const cidr of list) {\n      if (isCidrV6(cidr)) {\n        throw this.invalidCIDRError('CIDR whitelist can only contain IPv4 addresses, ' + cidr + ' is IPv6');\n      }\n\n      if (!isCidrV4(cidr)) {\n        throw this.invalidCIDRError('CIDR whitelist contains invalid CIDR entry: ' + cidr);\n      }\n    }\n\n    return list;\n  }\n\n}\n\nmodule.exports = Token;","map":{"version":3,"names":["Table","require","chalk","v4","isCidrV4","v6","isCidrV6","log","profile","otplease","pulseTillDone","readUserInfo","BaseCommand","Token","description","name","usage","params","ignoreImplicitWorkspace","completion","opts","argv","conf","remain","subcommands","length","includes","Error","exec","args","cb","gauge","show","list","rm","slice","create","usageError","config","info","tokens","withPromise","listTokens","json","npm","output","JSON","stringify","parseable","join","forEach","token","key","created","readonly","cidr_whitelist","generateTokenIds","idWidth","reduce","acc","Math","max","id","table","head","colWidths","push","String","toString","toRemove","progress","newItem","matches","filter","indexOf","tokenMatches","some","t","Promise","all","map","removeToken","cidr","readOnly","password","then","validCIDR","validateCIDRList","createToken","result","updated","Object","keys","k","bold","flatOptions","creds","getCredentialsByURI","registry","auth","username","basic","Buffer","from","split","otp","invalidCIDRError","msg","assign","code","minLength","byId","ii","match","ot","cidrs","maybeList","Array","isArray","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/lib/commands/token.js"],"sourcesContent":["const Table = require('cli-table3')\nconst chalk = require('chalk')\nconst { v4: isCidrV4, v6: isCidrV6 } = require('is-cidr')\nconst log = require('../utils/log-shim.js')\nconst profile = require('npm-profile')\n\nconst otplease = require('../utils/otplease.js')\nconst pulseTillDone = require('../utils/pulse-till-done.js')\nconst readUserInfo = require('../utils/read-user-info.js')\n\nconst BaseCommand = require('../base-command.js')\nclass Token extends BaseCommand {\n  static description = 'Manage your authentication tokens'\n  static name = 'token'\n  static usage = ['list', 'revoke <id|token>', 'create [--read-only] [--cidr=list]']\n  static params = ['read-only', 'cidr', 'registry', 'otp']\n  static ignoreImplicitWorkspace = true\n\n  async completion (opts) {\n    const argv = opts.conf.argv.remain\n    const subcommands = ['list', 'revoke', 'create']\n    if (argv.length === 2) {\n      return subcommands\n    }\n\n    if (subcommands.includes(argv[2])) {\n      return []\n    }\n\n    throw new Error(argv[2] + ' not recognized')\n  }\n\n  async exec (args, cb) {\n    log.gauge.show('token')\n    if (args.length === 0) {\n      return this.list()\n    }\n    switch (args[0]) {\n      case 'list':\n      case 'ls':\n        return this.list()\n      case 'delete':\n      case 'revoke':\n      case 'remove':\n      case 'rm':\n        return this.rm(args.slice(1))\n      case 'create':\n        return this.create(args.slice(1))\n      default:\n        throw this.usageError(`${args[0]} is not a recognized subcommand.`)\n    }\n  }\n\n  async list () {\n    const conf = this.config()\n    log.info('token', 'getting list')\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf))\n    if (conf.json) {\n      this.npm.output(JSON.stringify(tokens, null, 2))\n      return\n    } else if (conf.parseable) {\n      this.npm.output(['key', 'token', 'created', 'readonly', 'CIDR whitelist'].join('\\t'))\n      tokens.forEach(token => {\n        this.npm.output(\n          [\n            token.key,\n            token.token,\n            token.created,\n            token.readonly ? 'true' : 'false',\n            token.cidr_whitelist ? token.cidr_whitelist.join(',') : '',\n          ].join('\\t')\n        )\n      })\n      return\n    }\n    this.generateTokenIds(tokens, 6)\n    const idWidth = tokens.reduce((acc, token) => Math.max(acc, token.id.length), 0)\n    const table = new Table({\n      head: ['id', 'token', 'created', 'readonly', 'CIDR whitelist'],\n      colWidths: [Math.max(idWidth, 2) + 2, 9, 12, 10],\n    })\n    tokens.forEach(token => {\n      table.push([\n        token.id,\n        token.token + '…',\n        String(token.created).slice(0, 10),\n        token.readonly ? 'yes' : 'no',\n        token.cidr_whitelist ? token.cidr_whitelist.join(', ') : '',\n      ])\n    })\n    this.npm.output(table.toString())\n  }\n\n  async rm (args) {\n    if (args.length === 0) {\n      throw this.usageError('`<tokenKey>` argument is required.')\n    }\n\n    const conf = this.config()\n    const toRemove = []\n    const progress = log.newItem('removing tokens', toRemove.length)\n    progress.info('token', 'getting existing list')\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf))\n    args.forEach(id => {\n      const matches = tokens.filter(token => token.key.indexOf(id) === 0)\n      if (matches.length === 1) {\n        toRemove.push(matches[0].key)\n      } else if (matches.length > 1) {\n        throw new Error(\n          /* eslint-disable-next-line max-len */\n          `Token ID \"${id}\" was ambiguous, a new token may have been created since you last ran \\`npm token list\\`.`\n        )\n      } else {\n        const tokenMatches = tokens.some(t => id.indexOf(t.token) === 0)\n        if (!tokenMatches) {\n          throw new Error(`Unknown token id or value \"${id}\".`)\n        }\n\n        toRemove.push(id)\n      }\n    })\n    await Promise.all(\n      toRemove.map(key => {\n        return otplease(this.npm, conf, conf => {\n          return profile.removeToken(key, conf)\n        })\n      })\n    )\n    if (conf.json) {\n      this.npm.output(JSON.stringify(toRemove))\n    } else if (conf.parseable) {\n      this.npm.output(toRemove.join('\\t'))\n    } else {\n      this.npm.output('Removed ' + toRemove.length + ' token' + (toRemove.length !== 1 ? 's' : ''))\n    }\n  }\n\n  async create (args) {\n    const conf = this.config()\n    const cidr = conf.cidr\n    const readonly = conf.readOnly\n\n    return readUserInfo\n      .password()\n      .then(password => {\n        const validCIDR = this.validateCIDRList(cidr)\n        log.info('token', 'creating')\n        return pulseTillDone.withPromise(\n          otplease(this.npm, conf, conf => {\n            return profile.createToken(password, readonly, validCIDR, conf)\n          })\n        )\n      })\n      .then(result => {\n        delete result.key\n        delete result.updated\n        if (conf.json) {\n          this.npm.output(JSON.stringify(result))\n        } else if (conf.parseable) {\n          Object.keys(result).forEach(k => this.npm.output(k + '\\t' + result[k]))\n        } else {\n          const table = new Table()\n          for (const k of Object.keys(result)) {\n            table.push({ [chalk.bold(k)]: String(result[k]) })\n          }\n          this.npm.output(table.toString())\n        }\n      })\n  }\n\n  config () {\n    const conf = { ...this.npm.flatOptions }\n    const creds = this.npm.config.getCredentialsByURI(conf.registry)\n    if (creds.token) {\n      conf.auth = { token: creds.token }\n    } else if (creds.username) {\n      conf.auth = {\n        basic: {\n          username: creds.username,\n          password: creds.password,\n        },\n      }\n    } else if (creds.auth) {\n      const auth = Buffer.from(creds.auth, 'base64').toString().split(':', 2)\n      conf.auth = {\n        basic: {\n          username: auth[0],\n          password: auth[1],\n        },\n      }\n    } else {\n      conf.auth = {}\n    }\n\n    if (conf.otp) {\n      conf.auth.otp = conf.otp\n    }\n    return conf\n  }\n\n  invalidCIDRError (msg) {\n    return Object.assign(new Error(msg), { code: 'EINVALIDCIDR' })\n  }\n\n  generateTokenIds (tokens, minLength) {\n    const byId = {}\n    for (const token of tokens) {\n      token.id = token.key\n      for (let ii = minLength; ii < token.key.length; ++ii) {\n        const match = tokens.some(\n          ot => ot !== token && ot.key.slice(0, ii) === token.key.slice(0, ii)\n        )\n        if (!match) {\n          token.id = token.key.slice(0, ii)\n          break\n        }\n      }\n      byId[token.id] = token\n    }\n    return byId\n  }\n\n  validateCIDRList (cidrs) {\n    const maybeList = cidrs ? (Array.isArray(cidrs) ? cidrs : [cidrs]) : []\n    const list = maybeList.length === 1 ? maybeList[0].split(/,\\s*/) : maybeList\n    for (const cidr of list) {\n      if (isCidrV6(cidr)) {\n        throw this.invalidCIDRError(\n          'CIDR whitelist can only contain IPv4 addresses, ' + cidr + ' is IPv6'\n        )\n      }\n\n      if (!isCidrV4(cidr)) {\n        throw this.invalidCIDRError('CIDR whitelist contains invalid CIDR entry: ' + cidr)\n      }\n    }\n    return list\n  }\n}\nmodule.exports = Token\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}