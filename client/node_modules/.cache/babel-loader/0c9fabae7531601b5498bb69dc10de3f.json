{"ast":null,"code":"const {\n  info,\n  debug\n} = require('./debug');\n\nconst utils = require('./utils');\n\nclass Cell {\n  /**\n   * A representation of a cell within the table.\n   * Implementations must have `init` and `draw` methods,\n   * as well as `colSpan`, `rowSpan`, `desiredHeight` and `desiredWidth` properties.\n   * @param options\n   * @constructor\n   */\n  constructor(options) {\n    this.setOptions(options);\n    /**\n     * Each cell will have it's `x` and `y` values set by the `layout-manager` prior to\n     * `init` being called;\n     * @type {Number}\n     */\n\n    this.x = null;\n    this.y = null;\n  }\n\n  setOptions(options) {\n    if (['boolean', 'number', 'string'].indexOf(typeof options) !== -1) {\n      options = {\n        content: '' + options\n      };\n    }\n\n    options = options || {};\n    this.options = options;\n    let content = options.content;\n\n    if (['boolean', 'number', 'string'].indexOf(typeof content) !== -1) {\n      this.content = String(content);\n    } else if (!content) {\n      this.content = this.options.href || '';\n    } else {\n      throw new Error('Content needs to be a primitive, got: ' + typeof content);\n    }\n\n    this.colSpan = options.colSpan || 1;\n    this.rowSpan = options.rowSpan || 1;\n\n    if (this.options.href) {\n      Object.defineProperty(this, 'href', {\n        get() {\n          return this.options.href;\n        }\n\n      });\n    }\n  }\n\n  mergeTableOptions(tableOptions, cells) {\n    this.cells = cells;\n    let optionsChars = this.options.chars || {};\n    let tableChars = tableOptions.chars;\n    let chars = this.chars = {};\n    CHAR_NAMES.forEach(function (name) {\n      setOption(optionsChars, tableChars, name, chars);\n    });\n    this.truncate = this.options.truncate || tableOptions.truncate;\n    let style = this.options.style = this.options.style || {};\n    let tableStyle = tableOptions.style;\n    setOption(style, tableStyle, 'padding-left', this);\n    setOption(style, tableStyle, 'padding-right', this);\n    this.head = style.head || tableStyle.head;\n    this.border = style.border || tableStyle.border;\n    this.fixedWidth = tableOptions.colWidths[this.x];\n    this.lines = this.computeLines(tableOptions);\n    this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight;\n    this.desiredHeight = this.lines.length;\n  }\n\n  computeLines(tableOptions) {\n    if (this.fixedWidth && (tableOptions.wordWrap || tableOptions.textWrap)) {\n      this.fixedWidth -= this.paddingLeft + this.paddingRight;\n\n      if (this.colSpan) {\n        let i = 1;\n\n        while (i < this.colSpan) {\n          this.fixedWidth += tableOptions.colWidths[this.x + i];\n          i++;\n        }\n      }\n\n      const {\n        wrapOnWordBoundary = true\n      } = tableOptions;\n      return this.wrapLines(utils.wordWrap(this.fixedWidth, this.content, wrapOnWordBoundary));\n    }\n\n    return this.wrapLines(this.content.split('\\n'));\n  }\n\n  wrapLines(computedLines) {\n    const lines = utils.colorizeLines(computedLines);\n\n    if (this.href) {\n      return lines.map(line => utils.hyperlink(this.href, line));\n    }\n\n    return lines;\n  }\n  /**\n   * Initializes the Cells data structure.\n   *\n   * @param tableOptions - A fully populated set of tableOptions.\n   * In addition to the standard default values, tableOptions must have fully populated the\n   * `colWidths` and `rowWidths` arrays. Those arrays must have lengths equal to the number\n   * of columns or rows (respectively) in this table, and each array item must be a Number.\n   *\n   */\n\n\n  init(tableOptions) {\n    let x = this.x;\n    let y = this.y;\n    this.widths = tableOptions.colWidths.slice(x, x + this.colSpan);\n    this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan);\n    this.width = this.widths.reduce(sumPlusOne, -1);\n    this.height = this.heights.reduce(sumPlusOne, -1);\n    this.hAlign = this.options.hAlign || tableOptions.colAligns[x];\n    this.vAlign = this.options.vAlign || tableOptions.rowAligns[y];\n    this.drawRight = x + this.colSpan == tableOptions.colWidths.length;\n  }\n  /**\n   * Draws the given line of the cell.\n   * This default implementation defers to methods `drawTop`, `drawBottom`, `drawLine` and `drawEmpty`.\n   * @param lineNum - can be `top`, `bottom` or a numerical line number.\n   * @param spanningCell - will be a number if being called from a RowSpanCell, and will represent how\n   * many rows below it's being called from. Otherwise it's undefined.\n   * @returns {String} The representation of this line.\n   */\n\n\n  draw(lineNum, spanningCell) {\n    if (lineNum == 'top') return this.drawTop(this.drawRight);\n    if (lineNum == 'bottom') return this.drawBottom(this.drawRight);\n    let content = utils.truncate(this.content, 10, this.truncate);\n\n    if (!lineNum) {\n      info(`${this.y}-${this.x}: ${this.rowSpan - lineNum}x${this.colSpan} Cell ${content}`);\n    } else {// debug(`${lineNum}-${this.x}: 1x${this.colSpan} RowSpanCell ${content}`);\n    }\n\n    let padLen = Math.max(this.height - this.lines.length, 0);\n    let padTop;\n\n    switch (this.vAlign) {\n      case 'center':\n        padTop = Math.ceil(padLen / 2);\n        break;\n\n      case 'bottom':\n        padTop = padLen;\n        break;\n\n      default:\n        padTop = 0;\n    }\n\n    if (lineNum < padTop || lineNum >= padTop + this.lines.length) {\n      return this.drawEmpty(this.drawRight, spanningCell);\n    }\n\n    let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;\n    return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);\n  }\n  /**\n   * Renders the top line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n\n\n  drawTop(drawRight) {\n    let content = [];\n\n    if (this.cells) {\n      //TODO: cells should always exist - some tests don't fill it in though\n      this.widths.forEach(function (width, index) {\n        content.push(this._topLeftChar(index));\n        content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], width));\n      }, this);\n    } else {\n      content.push(this._topLeftChar(0));\n      content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], this.width));\n    }\n\n    if (drawRight) {\n      content.push(this.chars[this.y == 0 ? 'topRight' : 'rightMid']);\n    }\n\n    return this.wrapWithStyleColors('border', content.join(''));\n  }\n\n  _topLeftChar(offset) {\n    let x = this.x + offset;\n    let leftChar;\n\n    if (this.y == 0) {\n      leftChar = x == 0 ? 'topLeft' : offset == 0 ? 'topMid' : 'top';\n    } else {\n      if (x == 0) {\n        leftChar = 'leftMid';\n      } else {\n        leftChar = offset == 0 ? 'midMid' : 'bottomMid';\n\n        if (this.cells) {\n          //TODO: cells should always exist - some tests don't fill it in though\n          let spanAbove = this.cells[this.y - 1][x] instanceof Cell.ColSpanCell;\n\n          if (spanAbove) {\n            leftChar = offset == 0 ? 'topMid' : 'mid';\n          }\n\n          if (offset == 0) {\n            let i = 1;\n\n            while (this.cells[this.y][x - i] instanceof Cell.ColSpanCell) {\n              i++;\n            }\n\n            if (this.cells[this.y][x - i] instanceof Cell.RowSpanCell) {\n              leftChar = 'leftMid';\n            }\n          }\n        }\n      }\n    }\n\n    return this.chars[leftChar];\n  }\n\n  wrapWithStyleColors(styleProperty, content) {\n    if (this[styleProperty] && this[styleProperty].length) {\n      try {\n        let colors = require('@colors/colors/safe');\n\n        for (let i = this[styleProperty].length - 1; i >= 0; i--) {\n          colors = colors[this[styleProperty][i]];\n        }\n\n        return colors(content);\n      } catch (e) {\n        return content;\n      }\n    } else {\n      return content;\n    }\n  }\n  /**\n   * Renders a line of text.\n   * @param lineNum - Which line of text to render. This is not necessarily the line within the cell.\n   * There may be top-padding above the first line of text.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param forceTruncationSymbol - `true` if the rendered text should end with the truncation symbol even\n   * if the text fits. This is used when the cell is vertically truncated. If `false` the text should\n   * only include the truncation symbol if the text will not fit horizontally within the cell width.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n\n\n  drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n\n    let leftPadding = utils.repeat(' ', this.paddingLeft);\n    let right = drawRight ? this.chars['right'] : '';\n    let rightPadding = utils.repeat(' ', this.paddingRight);\n    let line = this.lines[lineNum];\n    let len = this.width - (this.paddingLeft + this.paddingRight);\n    if (forceTruncationSymbol) line += this.truncate || '…';\n    let content = utils.truncate(line, len, this.truncate);\n    content = utils.pad(content, len, ' ', this.hAlign);\n    content = leftPadding + content + rightPadding;\n    return this.stylizeLine(left, content, right);\n  }\n\n  stylizeLine(left, content, right) {\n    left = this.wrapWithStyleColors('border', left);\n    right = this.wrapWithStyleColors('border', right);\n\n    if (this.y === 0) {\n      content = this.wrapWithStyleColors('head', content);\n    }\n\n    return left + content + right;\n  }\n  /**\n   * Renders the bottom line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n\n\n  drawBottom(drawRight) {\n    let left = this.chars[this.x == 0 ? 'bottomLeft' : 'bottomMid'];\n    let content = utils.repeat(this.chars.bottom, this.width);\n    let right = drawRight ? this.chars['bottomRight'] : '';\n    return this.wrapWithStyleColors('border', left + content + right);\n  }\n  /**\n   * Renders a blank line of text within the cell. Used for top and/or bottom padding.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n\n\n  drawEmpty(drawRight, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n\n    let right = drawRight ? this.chars['right'] : '';\n    let content = utils.repeat(' ', this.width);\n    return this.stylizeLine(left, content, right);\n  }\n\n}\n\nclass ColSpanCell {\n  /**\n   * A Cell that doesn't do anything. It just draws empty lines.\n   * Used as a placeholder in column spanning.\n   * @constructor\n   */\n  constructor() {}\n\n  draw(lineNum) {\n    if (typeof lineNum === 'number') {\n      debug(`${this.y}-${this.x}: 1x1 ColSpanCell`);\n    }\n\n    return '';\n  }\n\n  init() {}\n\n  mergeTableOptions() {}\n\n}\n\nclass RowSpanCell {\n  /**\n   * A placeholder Cell for a Cell that spans multiple rows.\n   * It delegates rendering to the original cell, but adds the appropriate offset.\n   * @param originalCell\n   * @constructor\n   */\n  constructor(originalCell) {\n    this.originalCell = originalCell;\n  }\n\n  init(tableOptions) {\n    let y = this.y;\n    let originalY = this.originalCell.y;\n    this.cellOffset = y - originalY;\n    this.offset = findDimension(tableOptions.rowHeights, originalY, this.cellOffset);\n  }\n\n  draw(lineNum) {\n    if (lineNum == 'top') {\n      return this.originalCell.draw(this.offset, this.cellOffset);\n    }\n\n    if (lineNum == 'bottom') {\n      return this.originalCell.draw('bottom');\n    }\n\n    debug(`${this.y}-${this.x}: 1x${this.colSpan} RowSpanCell for ${this.originalCell.content}`);\n    return this.originalCell.draw(this.offset + 1 + lineNum);\n  }\n\n  mergeTableOptions() {}\n\n}\n\nfunction firstDefined() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return args.filter(v => v !== undefined && v !== null).shift();\n} // HELPER FUNCTIONS\n\n\nfunction setOption(objA, objB, nameB, targetObj) {\n  let nameA = nameB.split('-');\n\n  if (nameA.length > 1) {\n    nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1);\n    nameA = nameA.join('');\n    targetObj[nameA] = firstDefined(objA[nameA], objA[nameB], objB[nameA], objB[nameB]);\n  } else {\n    targetObj[nameB] = firstDefined(objA[nameB], objB[nameB]);\n  }\n}\n\nfunction findDimension(dimensionTable, startingIndex, span) {\n  let ret = dimensionTable[startingIndex];\n\n  for (let i = 1; i < span; i++) {\n    ret += 1 + dimensionTable[startingIndex + i];\n  }\n\n  return ret;\n}\n\nfunction sumPlusOne(a, b) {\n  return a + b + 1;\n}\n\nlet CHAR_NAMES = ['top', 'top-mid', 'top-left', 'top-right', 'bottom', 'bottom-mid', 'bottom-left', 'bottom-right', 'left', 'left-mid', 'mid', 'mid-mid', 'right', 'right-mid', 'middle'];\nmodule.exports = Cell;\nmodule.exports.ColSpanCell = ColSpanCell;\nmodule.exports.RowSpanCell = RowSpanCell;","map":{"version":3,"names":["info","debug","require","utils","Cell","constructor","options","setOptions","x","y","indexOf","content","String","href","Error","colSpan","rowSpan","Object","defineProperty","get","mergeTableOptions","tableOptions","cells","optionsChars","chars","tableChars","CHAR_NAMES","forEach","name","setOption","truncate","style","tableStyle","head","border","fixedWidth","colWidths","lines","computeLines","desiredWidth","strlen","paddingLeft","paddingRight","desiredHeight","length","wordWrap","textWrap","i","wrapOnWordBoundary","wrapLines","split","computedLines","colorizeLines","map","line","hyperlink","init","widths","slice","heights","rowHeights","width","reduce","sumPlusOne","height","hAlign","colAligns","vAlign","rowAligns","drawRight","draw","lineNum","spanningCell","drawTop","drawBottom","padLen","Math","max","padTop","ceil","drawEmpty","forceTruncation","drawLine","index","push","_topLeftChar","repeat","wrapWithStyleColors","join","offset","leftChar","spanAbove","ColSpanCell","RowSpanCell","styleProperty","colors","e","forceTruncationSymbol","left","cellLeft","leftPadding","right","rightPadding","len","pad","stylizeLine","bottom","originalCell","originalY","cellOffset","findDimension","firstDefined","args","filter","v","undefined","shift","objA","objB","nameB","targetObj","nameA","charAt","toUpperCase","substr","dimensionTable","startingIndex","span","ret","a","b","module","exports"],"sources":["/Users/chelsea/Documents/0_AllCoding/shoppingstories-v3/node_modules/npm/node_modules/cli-table3/src/cell.js"],"sourcesContent":["const { info, debug } = require('./debug');\nconst utils = require('./utils');\n\nclass Cell {\n  /**\n   * A representation of a cell within the table.\n   * Implementations must have `init` and `draw` methods,\n   * as well as `colSpan`, `rowSpan`, `desiredHeight` and `desiredWidth` properties.\n   * @param options\n   * @constructor\n   */\n  constructor(options) {\n    this.setOptions(options);\n\n    /**\n     * Each cell will have it's `x` and `y` values set by the `layout-manager` prior to\n     * `init` being called;\n     * @type {Number}\n     */\n    this.x = null;\n    this.y = null;\n  }\n\n  setOptions(options) {\n    if (['boolean', 'number', 'string'].indexOf(typeof options) !== -1) {\n      options = { content: '' + options };\n    }\n    options = options || {};\n    this.options = options;\n    let content = options.content;\n    if (['boolean', 'number', 'string'].indexOf(typeof content) !== -1) {\n      this.content = String(content);\n    } else if (!content) {\n      this.content = this.options.href || '';\n    } else {\n      throw new Error('Content needs to be a primitive, got: ' + typeof content);\n    }\n    this.colSpan = options.colSpan || 1;\n    this.rowSpan = options.rowSpan || 1;\n    if (this.options.href) {\n      Object.defineProperty(this, 'href', {\n        get() {\n          return this.options.href;\n        },\n      });\n    }\n  }\n\n  mergeTableOptions(tableOptions, cells) {\n    this.cells = cells;\n\n    let optionsChars = this.options.chars || {};\n    let tableChars = tableOptions.chars;\n    let chars = (this.chars = {});\n    CHAR_NAMES.forEach(function (name) {\n      setOption(optionsChars, tableChars, name, chars);\n    });\n\n    this.truncate = this.options.truncate || tableOptions.truncate;\n\n    let style = (this.options.style = this.options.style || {});\n    let tableStyle = tableOptions.style;\n    setOption(style, tableStyle, 'padding-left', this);\n    setOption(style, tableStyle, 'padding-right', this);\n    this.head = style.head || tableStyle.head;\n    this.border = style.border || tableStyle.border;\n\n    this.fixedWidth = tableOptions.colWidths[this.x];\n    this.lines = this.computeLines(tableOptions);\n\n    this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight;\n    this.desiredHeight = this.lines.length;\n  }\n\n  computeLines(tableOptions) {\n    if (this.fixedWidth && (tableOptions.wordWrap || tableOptions.textWrap)) {\n      this.fixedWidth -= this.paddingLeft + this.paddingRight;\n      if (this.colSpan) {\n        let i = 1;\n        while (i < this.colSpan) {\n          this.fixedWidth += tableOptions.colWidths[this.x + i];\n          i++;\n        }\n      }\n      const { wrapOnWordBoundary = true } = tableOptions;\n      return this.wrapLines(utils.wordWrap(this.fixedWidth, this.content, wrapOnWordBoundary));\n    }\n    return this.wrapLines(this.content.split('\\n'));\n  }\n\n  wrapLines(computedLines) {\n    const lines = utils.colorizeLines(computedLines);\n    if (this.href) {\n      return lines.map((line) => utils.hyperlink(this.href, line));\n    }\n    return lines;\n  }\n\n  /**\n   * Initializes the Cells data structure.\n   *\n   * @param tableOptions - A fully populated set of tableOptions.\n   * In addition to the standard default values, tableOptions must have fully populated the\n   * `colWidths` and `rowWidths` arrays. Those arrays must have lengths equal to the number\n   * of columns or rows (respectively) in this table, and each array item must be a Number.\n   *\n   */\n  init(tableOptions) {\n    let x = this.x;\n    let y = this.y;\n    this.widths = tableOptions.colWidths.slice(x, x + this.colSpan);\n    this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan);\n    this.width = this.widths.reduce(sumPlusOne, -1);\n    this.height = this.heights.reduce(sumPlusOne, -1);\n\n    this.hAlign = this.options.hAlign || tableOptions.colAligns[x];\n    this.vAlign = this.options.vAlign || tableOptions.rowAligns[y];\n\n    this.drawRight = x + this.colSpan == tableOptions.colWidths.length;\n  }\n\n  /**\n   * Draws the given line of the cell.\n   * This default implementation defers to methods `drawTop`, `drawBottom`, `drawLine` and `drawEmpty`.\n   * @param lineNum - can be `top`, `bottom` or a numerical line number.\n   * @param spanningCell - will be a number if being called from a RowSpanCell, and will represent how\n   * many rows below it's being called from. Otherwise it's undefined.\n   * @returns {String} The representation of this line.\n   */\n  draw(lineNum, spanningCell) {\n    if (lineNum == 'top') return this.drawTop(this.drawRight);\n    if (lineNum == 'bottom') return this.drawBottom(this.drawRight);\n    let content = utils.truncate(this.content, 10, this.truncate);\n    if (!lineNum) {\n      info(`${this.y}-${this.x}: ${this.rowSpan - lineNum}x${this.colSpan} Cell ${content}`);\n    } else {\n      // debug(`${lineNum}-${this.x}: 1x${this.colSpan} RowSpanCell ${content}`);\n    }\n    let padLen = Math.max(this.height - this.lines.length, 0);\n    let padTop;\n    switch (this.vAlign) {\n      case 'center':\n        padTop = Math.ceil(padLen / 2);\n        break;\n      case 'bottom':\n        padTop = padLen;\n        break;\n      default:\n        padTop = 0;\n    }\n    if (lineNum < padTop || lineNum >= padTop + this.lines.length) {\n      return this.drawEmpty(this.drawRight, spanningCell);\n    }\n    let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;\n    return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);\n  }\n\n  /**\n   * Renders the top line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n  drawTop(drawRight) {\n    let content = [];\n    if (this.cells) {\n      //TODO: cells should always exist - some tests don't fill it in though\n      this.widths.forEach(function (width, index) {\n        content.push(this._topLeftChar(index));\n        content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], width));\n      }, this);\n    } else {\n      content.push(this._topLeftChar(0));\n      content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], this.width));\n    }\n    if (drawRight) {\n      content.push(this.chars[this.y == 0 ? 'topRight' : 'rightMid']);\n    }\n    return this.wrapWithStyleColors('border', content.join(''));\n  }\n\n  _topLeftChar(offset) {\n    let x = this.x + offset;\n    let leftChar;\n    if (this.y == 0) {\n      leftChar = x == 0 ? 'topLeft' : offset == 0 ? 'topMid' : 'top';\n    } else {\n      if (x == 0) {\n        leftChar = 'leftMid';\n      } else {\n        leftChar = offset == 0 ? 'midMid' : 'bottomMid';\n        if (this.cells) {\n          //TODO: cells should always exist - some tests don't fill it in though\n          let spanAbove = this.cells[this.y - 1][x] instanceof Cell.ColSpanCell;\n          if (spanAbove) {\n            leftChar = offset == 0 ? 'topMid' : 'mid';\n          }\n          if (offset == 0) {\n            let i = 1;\n            while (this.cells[this.y][x - i] instanceof Cell.ColSpanCell) {\n              i++;\n            }\n            if (this.cells[this.y][x - i] instanceof Cell.RowSpanCell) {\n              leftChar = 'leftMid';\n            }\n          }\n        }\n      }\n    }\n    return this.chars[leftChar];\n  }\n\n  wrapWithStyleColors(styleProperty, content) {\n    if (this[styleProperty] && this[styleProperty].length) {\n      try {\n        let colors = require('@colors/colors/safe');\n        for (let i = this[styleProperty].length - 1; i >= 0; i--) {\n          colors = colors[this[styleProperty][i]];\n        }\n        return colors(content);\n      } catch (e) {\n        return content;\n      }\n    } else {\n      return content;\n    }\n  }\n\n  /**\n   * Renders a line of text.\n   * @param lineNum - Which line of text to render. This is not necessarily the line within the cell.\n   * There may be top-padding above the first line of text.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param forceTruncationSymbol - `true` if the rendered text should end with the truncation symbol even\n   * if the text fits. This is used when the cell is vertically truncated. If `false` the text should\n   * only include the truncation symbol if the text will not fit horizontally within the cell width.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n  drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n    let leftPadding = utils.repeat(' ', this.paddingLeft);\n    let right = drawRight ? this.chars['right'] : '';\n    let rightPadding = utils.repeat(' ', this.paddingRight);\n    let line = this.lines[lineNum];\n    let len = this.width - (this.paddingLeft + this.paddingRight);\n    if (forceTruncationSymbol) line += this.truncate || '…';\n    let content = utils.truncate(line, len, this.truncate);\n    content = utils.pad(content, len, ' ', this.hAlign);\n    content = leftPadding + content + rightPadding;\n    return this.stylizeLine(left, content, right);\n  }\n\n  stylizeLine(left, content, right) {\n    left = this.wrapWithStyleColors('border', left);\n    right = this.wrapWithStyleColors('border', right);\n    if (this.y === 0) {\n      content = this.wrapWithStyleColors('head', content);\n    }\n    return left + content + right;\n  }\n\n  /**\n   * Renders the bottom line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n  drawBottom(drawRight) {\n    let left = this.chars[this.x == 0 ? 'bottomLeft' : 'bottomMid'];\n    let content = utils.repeat(this.chars.bottom, this.width);\n    let right = drawRight ? this.chars['bottomRight'] : '';\n    return this.wrapWithStyleColors('border', left + content + right);\n  }\n\n  /**\n   * Renders a blank line of text within the cell. Used for top and/or bottom padding.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n  drawEmpty(drawRight, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n    let right = drawRight ? this.chars['right'] : '';\n    let content = utils.repeat(' ', this.width);\n    return this.stylizeLine(left, content, right);\n  }\n}\n\nclass ColSpanCell {\n  /**\n   * A Cell that doesn't do anything. It just draws empty lines.\n   * Used as a placeholder in column spanning.\n   * @constructor\n   */\n  constructor() {}\n\n  draw(lineNum) {\n    if (typeof lineNum === 'number') {\n      debug(`${this.y}-${this.x}: 1x1 ColSpanCell`);\n    }\n    return '';\n  }\n\n  init() {}\n\n  mergeTableOptions() {}\n}\n\nclass RowSpanCell {\n  /**\n   * A placeholder Cell for a Cell that spans multiple rows.\n   * It delegates rendering to the original cell, but adds the appropriate offset.\n   * @param originalCell\n   * @constructor\n   */\n  constructor(originalCell) {\n    this.originalCell = originalCell;\n  }\n\n  init(tableOptions) {\n    let y = this.y;\n    let originalY = this.originalCell.y;\n    this.cellOffset = y - originalY;\n    this.offset = findDimension(tableOptions.rowHeights, originalY, this.cellOffset);\n  }\n\n  draw(lineNum) {\n    if (lineNum == 'top') {\n      return this.originalCell.draw(this.offset, this.cellOffset);\n    }\n    if (lineNum == 'bottom') {\n      return this.originalCell.draw('bottom');\n    }\n    debug(`${this.y}-${this.x}: 1x${this.colSpan} RowSpanCell for ${this.originalCell.content}`);\n    return this.originalCell.draw(this.offset + 1 + lineNum);\n  }\n\n  mergeTableOptions() {}\n}\n\nfunction firstDefined(...args) {\n  return args.filter((v) => v !== undefined && v !== null).shift();\n}\n\n// HELPER FUNCTIONS\nfunction setOption(objA, objB, nameB, targetObj) {\n  let nameA = nameB.split('-');\n  if (nameA.length > 1) {\n    nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1);\n    nameA = nameA.join('');\n    targetObj[nameA] = firstDefined(objA[nameA], objA[nameB], objB[nameA], objB[nameB]);\n  } else {\n    targetObj[nameB] = firstDefined(objA[nameB], objB[nameB]);\n  }\n}\n\nfunction findDimension(dimensionTable, startingIndex, span) {\n  let ret = dimensionTable[startingIndex];\n  for (let i = 1; i < span; i++) {\n    ret += 1 + dimensionTable[startingIndex + i];\n  }\n  return ret;\n}\n\nfunction sumPlusOne(a, b) {\n  return a + b + 1;\n}\n\nlet CHAR_NAMES = [\n  'top',\n  'top-mid',\n  'top-left',\n  'top-right',\n  'bottom',\n  'bottom-mid',\n  'bottom-left',\n  'bottom-right',\n  'left',\n  'left-mid',\n  'mid',\n  'mid-mid',\n  'right',\n  'right-mid',\n  'middle',\n];\n\nmodule.exports = Cell;\nmodule.exports.ColSpanCell = ColSpanCell;\nmodule.exports.RowSpanCell = RowSpanCell;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}